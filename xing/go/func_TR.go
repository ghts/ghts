package xing

import (
	lb "github.com/ghts/ghts/lib"
	"github.com/ghts/ghts/lib/trade"
	"github.com/ghts/ghts/xing/base"
	"os"

	"fmt"
	"strconv"
	"strings"
	"time"
)

//func TrCFOAQ00600_선물옵션_주문체결내역(계좌번호 string, 선물옵션구분 xt.CFOAQ00600_선물옵션분류, 상품군 xt.T선옵_상품군,
//	체결구분 lb.T체결_구분, 조회_시작일, 조회_종료일 time.Time) (응답값 *xt.CFOAQ00600_선물옵션_주문체결내역_응답, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()
//
//	응답값 = new(xt.CFOAQ00600_선물옵션_주문체결내역_응답)
//
//	연속조회_여부 := false
//	연속키 := ""
//
//	for {
//		질의값 := new(xt.CFOAQ00600_선물옵션_주문체결내역_질의값)
//		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR선물옵션_주문체결내역조회_CFOAQ00600)
//		질의값.M레코드수량 = 1
//		질의값.M계좌번호 = 계좌번호
//		// 비밀번호	// 소켓 전송 안 함.
//		질의값.M조회_시작일 = lb.F2일자(조회_시작일)
//		질의값.M조회_종료일 = lb.F2일자(조회_종료일)
//		질의값.M선물옵션분류 = 선물옵션구분
//		질의값.M상품군 = 상품군
//		질의값.M체결구분 = 체결구분
//		질의값.M정렬구분 = lb.P정렬_역순
//		질의값.M연속조회_여부 = 연속조회_여부
//		질의값.M연속키 = 연속키
//
//		i응답값, 에러 := F질의_단일TR(질의값)
//		lb.F확인(에러)
//
//		수신값, ok := i응답값.(*xt.CFOAQ00600_선물옵션_주문체결내역_응답)
//		lb.F조건부_패닉(!ok, "TrCFOAQ00600, 예상하지 못한 자료형 : '%T'", i응답값)
//
//		응답값.M응답1 = 수신값.M응답1
//		응답값.M응답2 = 수신값.M응답2
//		응답값.M반복값_모음 = append(응답값.M반복값_모음, 수신값.M반복값_모음...)
//
//		if !수신값.M추가_연속조회_필요 {
//			break
//		}
//
//		연속조회_여부 = 수신값.M추가_연속조회_필요
//		연속키 = 수신값.M연속키
//	}
//
//	return 응답값, nil
//}

//func TrCFOAT00100_선물옵션_정상주문(계좌번호 string, 선옵_종목코드 string, 매매구분 lb.T매도_매수_구분,
//	호가유형 xt.T호가유형, 주문가격 float64, 주문수량 int64) (응답값 *xt.CFOAT00100_선물옵션_정상주문_응답, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()
//
//	질의값 := new(xt.CFOAT00100_선물옵션_정상주문_질의값)
//	질의값.S질의값_단일_종목 = lb.New질의값_단일_종목(xt.TR조회, xt.TR선물옵션_정상주문_CFOAT00100, 선옵_종목코드)
//	질의값.M계좌번호 = 계좌번호
//	질의값.M매매구분 = 매매구분
//	질의값.M호가유형 = 호가유형
//	질의값.M주문가격 = 주문가격
//	질의값.M주문수량 = 주문수량
//
//	i응답값, 에러 := F질의_단일TR(질의값)
//	lb.F확인(에러)
//
//	응답값, ok := i응답값.(*xt.CFOAT00100_선물옵션_정상주문_응답)
//	lb.F조건부_패닉(!ok, "TrCFOAT00100 예상하지 못한 자료형 : '%T'", i응답값)
//
//	return 응답값, nil
//}
//
//func TrCFOAT00200_선물옵션_정정주문(선옵_종목코드 string, 계좌번호 string, 매매구분 lb.T매도_매수_구분,
//	호가유형 xt.T호가유형, 원주문번호 int64, 주문가격 float64, 정정수량 int64) (응답값 *xt.CFOAT00200_선물옵션_정정주문_응답, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()
//
//	질의값 := new(xt.CFOAT00200_선물옵션_정정주문_질의값)
//	질의값.S질의값_단일_종목 = lb.New질의값_단일_종목_단순형()
//	질의값.S질의값_단일_종목.M구분 = xt.TR조회
//	질의값.S질의값_단일_종목.M코드 = xt.TR선물옵션_정정주문_CFOAT00200
//	질의값.S질의값_단일_종목.M종목코드 = 선옵_종목코드
//	질의값.M계좌번호 = 계좌번호
//	질의값.M매매구분 = 매매구분
//	질의값.M호가유형 = 호가유형
//	질의값.M원주문번호 = 원주문번호
//	질의값.M주문가격 = 주문가격
//	질의값.M정정수량 = 정정수량
//
//	for i := 0; i < 10; i++ { // 최대 10번 재시도
//		i응답값, 에러 := F질의_단일TR(질의값)
//
//		if 에러 != nil && (strings.Contains(에러.Error(), "원주문번호를 잘못") ||
//			strings.Contains(에러.Error(), "접수 대기 상태")) {
//			continue // 재시도
//		}
//
//		lb.F확인(에러)
//
//		응답값, ok := i응답값.(*xt.CFOAT00200_선물옵션_정정주문_응답)
//		lb.F조건부_패닉(!ok, "TrCFOAT00200() 예상하지 못한 자료형 : '%T'", i응답값)
//
//		if 응답값.M응답2 != nil && 응답값.M응답2.M주문번호 <= 0 {
//			continue
//		}
//
//		return 응답값, nil
//	}
//
//	return 응답값, nil
//}
//
//func TrCFOAT00300_선물옵션_취소주문(선옵_종목코드 string, 계좌번호 string, 원주문번호 int64, 취소수량 int64) (응답값 *xt.CFOAT00300_선물옵션_취소주문_응답, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()
//
//	질의값 := new(xt.CFOAT00300_선물옵션_취소주문_질의값)
//	질의값.S질의값_단일_종목 = lb.New질의값_단일_종목_단순형()
//	질의값.S질의값_단일_종목.M구분 = xt.TR조회
//	질의값.S질의값_단일_종목.M코드 = xt.TR선물옵션_취소주문_CFOAT00300
//	질의값.S질의값_단일_종목.M종목코드 = 선옵_종목코드
//	질의값.M계좌번호 = 계좌번호
//	질의값.M원주문번호 = 원주문번호
//	질의값.M취소수량 = 취소수량
//
//	for i := 0; i < 10; i++ { // 최대 10번 재시도
//		i응답값, 에러 := F질의_단일TR(질의값)
//
//		if 에러 != nil && (strings.Contains(에러.Error(), "원주문번호를 잘못") ||
//			strings.Contains(에러.Error(), "접수 대기 상태")) {
//			continue // 재시도
//		}
//
//		lb.F확인(에러)
//
//		응답값, ok := i응답값.(*xt.CFOAT00300_선물옵션_취소주문_응답)
//		lb.F조건부_패닉(!ok, "TrCFOAT00300() 예상하지 못한 자료형 : '%T'", i응답값)
//
//		if 응답값.M응답2 != nil && 응답값.M응답2.M주문번호 <= 0 {
//			continue
//		}
//
//		return 응답값, nil
//	}
//
//	return nil, lb.New에러("선물옵션 취소 주문 TR 실행 실패.")
//}
//
//func TrCFOBQ10500_선물옵션_예탁금_증거금_조회(계좌번호 string) (응답값 *xt.CFOBQ10500_선물옵션_예탁금_증거금_조회_응답, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()
//
//	응답값 = new(xt.CFOBQ10500_선물옵션_예탁금_증거금_조회_응답)
//
//	연속조회_여부 := false
//	연속키 := ""
//
//	for {
//		질의값 := new(xt.CFOBQ10500_선물옵션_예탁금_증거금_조회_질의값)
//		질의값.S질의값_기본형 = lb.New질의값_기본형(lb.TR조회, xt.TR선물옵션_예탁금_증거금_조회_CFOBQ10500)
//		질의값.M레코드수량 = 1
//		질의값.M계좌번호 = 계좌번호
//		질의값.M연속조회_여부 = 연속조회_여부
//		질의값.M연속키 = 연속키
//
//		i응답값, 에러 := F질의_단일TR(질의값)
//		lb.F확인(에러)
//
//		수신값, ok := i응답값.(*xt.CFOBQ10500_선물옵션_예탁금_증거금_조회_응답)
//		lb.F조건부_패닉(!ok, "TrCFOBQ10500() 예상하지 못한 자료형 : '%T'", i응답값)
//
//		응답값.M응답1 = 수신값.M응답1
//		응답값.M응답2 = 수신값.M응답2
//		응답값.M반복값_모음 = append(응답값.M반복값_모음, 수신값.M반복값_모음...)
//
//		if !수신값.M추가_연속조회_필요 {
//			break
//		}
//
//		연속조회_여부 = 수신값.M추가_연속조회_필요
//		연속키 = 수신값.M연속키
//	}
//
//	return 응답값, nil
//}
//
//func TrCFOFQ02400_선물옵션_미결제약정(계좌번호 string, 등록시장 xt.CFOFQ02400_등록시장, 매수일자 time.Time) (응답값 *xt.CFOFQ02400_선물옵션_미결제약정_응답, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()
//
//	응답값 = new(xt.CFOFQ02400_선물옵션_미결제약정_응답)
//
//	연속조회_여부 := false
//	연속키 := ""
//
//	for {
//		질의값 := new(xt.CFOFQ02400_선물옵션_미결제약정_질의값)
//		질의값.S질의값_기본형 = lb.New질의값_기본형(lb.TR조회, xt.TR선물옵션_미결제약정_현황_CFOFQ02400)
//		질의값.M레코드수량 = 1
//		질의값.M계좌번호 = 계좌번호
//		// 비밀번호
//		질의값.M등록시장코드 = 등록시장
//		질의값.M매수일자 = 매수일자.Format("20060102")
//		질의값.M연속조회_여부 = 연속조회_여부
//		질의값.M연속키 = 연속키
//
//		i응답값, 에러 := F질의_단일TR(질의값)
//		lb.F확인(에러)
//
//		수신값, ok := i응답값.(*xt.CFOFQ02400_선물옵션_미결제약정_응답)
//		lb.F조건부_패닉(!ok, "TrCFOFQ02400() 예상하지 못한 자료형 : '%T'", i응답값)
//
//		응답값.M응답1 = 수신값.M응답1
//		응답값.M응답2 = 수신값.M응답2
//		응답값.M반복값1_모음 = append(응답값.M반복값1_모음, 수신값.M반복값1_모음...)
//		응답값.M반복값2_모음 = append(응답값.M반복값2_모음, 수신값.M반복값2_모음...)
//
//		if !수신값.M추가_연속조회_필요 {
//			break
//		}
//
//		연속조회_여부 = 수신값.M추가_연속조회_필요
//		연속키 = 수신값.M연속키
//	}
//
//	return 응답값, nil
//}

func TrCSPAT00600_현물_정상주문(질의값 *xt.CSPAT00600_현물_정상_주문_질의값) (응답값 *xt.CSPAT00600_현물_정상_주문_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	if 질의값.M호가유형 == lb.P호가_지정가 && 질의값.M주문단가 == 0 {
		return nil, lb.New에러with출력("%v %v 지정가 주문 단가 0.", 질의값.M계좌번호, 질의값.M종목코드)
	} else if 질의값.M주문수량 <= 0 {
		return nil, lb.New에러with출력("%v %v 잘못된 주문 수량 %v", 질의값.M계좌번호, 질의값.M코드, 질의값.M주문수량)
	} else if strings.HasPrefix(질의값.M종목코드, "5") {
		질의값.M종목코드 = "Q" + 질의값.M종목코드 // ETN 종목코드 보정
	}

	질의값.M주문단가 = F호가_필터(질의값.M종목코드, 질의값.M주문단가)

	if 질의값.M호가유형 == lb.P호가_조건부_지정가 && f조건부_지정가_주문_불가(질의값.M종목코드) {
		질의값.M호가유형 = lb.P호가_지정가
	} else if 질의값.M호가유형 == lb.P호가_조건부_지정가 {
		최근_조건부_지정가_주문_종목코드 = 질의값.M종목코드 // 호가 적합성 오류가 발생할 경우를 대비한 기록.
	}

	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.CSPAT00600_현물_정상_주문_응답)
	lb.F조건부_패닉(!ok, "TrCSPAT00600() 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil
}

func TrCSPAT00700_현물_정정주문(질의값 *xt.CSPAT00700_현물_정정_주문_질의값) (응답값 *xt.CSPAT00700_현물_정정_주문_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	// ETN 종목코드 보정
	if strings.HasPrefix(질의값.M종목코드, "5") {
		질의값.M종목코드 = "Q" + 질의값.M종목코드
	}

	질의값.M주문단가 = F호가_필터(질의값.M종목코드, 질의값.M주문단가)

	for i := 0; i < 3; i++ { // 최대 3번 재시도
		i응답값, 에러 := F질의_단일TR(질의값)

		if 에러 != nil && (strings.Contains(에러.Error(), "원주문번호를 잘못") ||
			strings.Contains(에러.Error(), "접수 대기 상태입니다")) {
			continue
		} else if 에러 != nil {
			return nil, 에러
		}

		응답값, ok := i응답값.(*xt.CSPAT00700_현물_정정_주문_응답)
		lb.F조건부_패닉(!ok, "TrCSPAT00700() 예상하지 못한 자료형 : '%T'", i응답값)

		if 응답값.M응답2 != nil && 응답값.M응답2.M주문번호 <= 0 {
			continue
		}

		return 응답값, nil
	}

	return nil, lb.New에러("정정 주문 TR 실행 실패.")
}

func TrCSPAT00800_현물_취소주문(질의값 *lb.S질의값_취소_주문) (응답값 *xt.CSPAT00800_현물_취소_주문_응답, 에러 error) {
	예외_처리 := lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}
	defer 예외_처리.S실행()

	// ETN 종목코드 보정
	if strings.HasPrefix(질의값.M종목코드, "5") {
		질의값.M종목코드 = "Q" + 질의값.M종목코드
	}

	for i := 0; i < 3; i++ { // 최대 3번 재시도
		if i응답값, 에러 := F질의_단일TR(질의값); 에러 != nil {
			if strings.Contains(에러.Error(), "원주문번호를 잘못") ||
				strings.Contains(에러.Error(), "접수 대기 상태") {
				continue // 재시도
			} else if strings.Contains(에러.Error(), "주문수량이 매매가능수량을 초과했습니다") {
				예외_처리.M출력_숨김 = true
				return nil, 에러
			} else {
				return nil, 에러
			}
		} else if 응답값, ok := i응답값.(*xt.CSPAT00800_현물_취소_주문_응답); !ok {
			return nil, lb.New에러("TrCSPAT00800() 예상하지 못한 자료형 : '%T'", i응답값)
		} else if 응답값.M응답2 != nil && 응답값.M응답2.M주문번호 <= 0 {
			에러 = lb.New에러("음의 주문번호.")
			continue
		} else {
			return 응답값, nil
		}
	}

	return nil, 에러
}

func TrCSPAQ12200_현물계좌_총평가(계좌번호 string) (값 *xt.CSPAQ12200_현물계좌_총평가_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 값 = nil }}.S실행()

	lb.F조건부_패닉(!F계좌번호_존재함(계좌번호), "존재하지 않는 계좌번호 : '%v'", 계좌번호)

	질의값 := lb.New질의값_문자열(xt.TR조회, xt.TR현물계좌_총평가_CSPAQ12200, 계좌번호)
	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.CSPAQ12200_현물계좌_총평가_응답)
	lb.F조건부_패닉(!ok, "TrCSPAQ12200 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil

}

func TrCSPAQ12300_현물계좌_잔고내역_조회(계좌번호 string, 단가_구분 xt.T단가_구분_CSPAQ12300,
	수수료_적용_여부 bool) (값_모음 map[string]*xt.CSPAQ12300_현물계좌_잔고내역_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 값_모음 = nil }}.S실행()

	lb.F조건부_패닉(!F계좌번호_존재함(계좌번호), "존재하지 않는 계좌번호 : '%v'", 계좌번호)

	값_모음 = make(map[string]*xt.CSPAQ12300_현물계좌_잔고내역_응답_반복값)
	연속조회_여부 := false
	연속키 := ""

	for {
		질의값 := new(xt.CSPAQ12300_현물계좌_잔고내역_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR현물계좌_잔고내역_조회_CSPAQ12300)
		질의값.M계좌번호 = 계좌번호
		질의값.M잔고생성_구분 = "0"                           // 0:전체, 1:현물, 9:선물대용
		질의값.M수수료적용_구분 = lb.F조건값(수수료_적용_여부, "1", "0") // 0:수수료 미적용, 1:수수료 적용
		질의값.D2잔고기준조회_구분 = "1"                        // 0:전부조회, 1:D2잔고 0이상만 조회
		질의값.M단가_구분 = strconv.Itoa(int(단가_구분))        // 0:평균단가, 1:BEP단가
		질의값.M연속조회_여부 = 연속조회_여부
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		수신값, ok := i응답값.(*xt.CSPAQ12300_현물계좌_잔고내역_응답)
		lb.F조건부_패닉(!ok, "TrCSPAQ12300() 예상하지 못한 자료형 : '%T'", i응답값)

		for _, 반복값 := range 수신값.M반복값_모음 {
			if strings.TrimSpace(반복값.M종목코드) == "" {
				continue
			} else if strings.HasPrefix(반복값.M종목코드, "Q") ||
				strings.HasPrefix(반복값.M종목코드, "A") {
				반복값.M종목코드 = 반복값.M종목코드[1:]
			}

			값_모음[반복값.M종목코드] = 반복값
		}

		if !수신값.M추가_연속조회_필요 {
			break
		}

		연속조회_여부 = 수신값.M추가_연속조회_필요
		연속키 = 수신값.M연속키
	}

	return 값_모음, nil
}

func TrCSPAQ13700_현물계좌_주문체결내역(계좌번호 string, 주문일 time.Time,
	매도_매수_구분 lb.T매도_매수_구분,
	체결_미체결_구분 xt.T주문_체결_미체결_구분_CSPAQ13700) (값_모음 []*xt.CSPAQ13700_현물계좌_주문체결내역_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 값_모음 = nil }}.S실행()

	lb.F조건부_패닉(!F계좌번호_존재함(계좌번호), "존재하지 않는 계좌번호 : '%v'", 계좌번호)

	값_모음 = make([]*xt.CSPAQ13700_현물계좌_주문체결내역_반복값, 0)

	연속조회_여부 := false
	연속키 := ""

	var 매매구분, 주문유형코드 string

	switch 매도_매수_구분 {
	case lb.P매도_매수_전체:
		매매구분 = "0"
		주문유형코드 = "00"
	case lb.P매도:
		매매구분 = "1"
		주문유형코드 = "98"
	case lb.P매수:
		매매구분 = "2"
		주문유형코드 = "99"
	default:
		panic(lb.New에러("예상하지 못한 매도 매수 구분 : %v", 매도_매수_구분))
	}

	const 역순구분 = "1"
	시작주문번호 := int64(0) // lb.F조건부_정수64(역순구분 == "1", 000000000, 999999999)

	for {
		질의값 := new(xt.CSPAQ13700_현물계좌_주문체결내역_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR현물계좌_주문체결내역_조회_CSPAQ13700)
		질의값.M계좌번호 = 계좌번호
		질의값.M주문시장코드 = "00"                       // "00":전체, "10":거래소, "20":코스닥
		질의값.M매매구분 = 매매구분                         // "0":전체, "1":매도, "2":매수
		질의값.M종목코드 = ""                           // 종목코드 없으면 모든 종목. 주식 : A+종목코드, ELW : J+종목코드
		질의값.M체결여부 = strconv.Itoa(int(체결_미체결_구분)) // "0":전체, "1":체결, "3":미체결
		질의값.M주문일 = 주문일.Format("20060102")        // 주문일
		질의값.M시작주문번호 = 시작주문번호                     // 역순구분이 순 : 000000000, 역순구분이 역순 : 999999999
		질의값.M역순구분 = 역순구분                         // "0":역순, "1":정순
		질의값.M주문유형코드 = 주문유형코드                     // "00":전체, "98":매도, "99":매수
		질의값.M연속조회_여부 = 연속조회_여부
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		수신값, ok := i응답값.(*xt.CSPAQ13700_현물계좌_주문체결내역_응답)
		lb.F조건부_패닉(!ok, "TrCSPAQ13700() 예상하지 못한 자료형 : '%T'", i응답값)

		값_모음 = append(값_모음, 수신값.M반복값_모음...)

		if !수신값.M추가_연속조회_필요 {
			break
		}

		연속조회_여부 = 수신값.M추가_연속조회_필요
		연속키 = 수신값.M연속키
	}

	return 값_모음, nil
}

func TrCSPAQ22200_현물계좌_예수금_주문가능금액(계좌번호 string) (값 *xt.CSPAQ22200_현물계좌_예수금_주문가능금액_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 값 = nil }}.S실행()

	lb.F조건부_패닉(!F계좌번호_존재함(계좌번호), "존재하지 않는 계좌번호 : '%v'", 계좌번호)

	질의값 := lb.New질의값_문자열(xt.TR조회, xt.TR현물계좌_예수금_주문가능금액_CSPAQ22200, 계좌번호)
	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.CSPAQ22200_현물계좌_예수금_주문가능금액_응답)
	lb.F조건부_패닉(!ok, "TrCSPAQ22200 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil
}

func TrT0150_현물_당일_매매일지(계좌번호 string) (응답값_모음 []*xt.T0150_현물_당일_매매일지_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	lb.F조건부_패닉(!F계좌번호_존재함(계좌번호), "존재하지 않는 계좌번호 : '%v'", 계좌번호)

	var 연속키_매매구분, 연속키_종목코드, 연속키_단가, 연속키_매체 string

	응답값_모음 = make([]*xt.T0150_현물_당일_매매일지_응답_반복값, 0)

	for {
		질의값 := new(xt.T0150_현물_당일_매매일지_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR현물_당일_매매일지_t0150)
		질의값.M계좌번호 = 계좌번호
		질의값.M연속키_매매구분 = 연속키_매매구분
		질의값.M연속키_종목코드 = 연속키_종목코드
		질의값.M연속키_단가 = 연속키_단가
		질의값.M연속키_매체 = 연속키_매체

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		if i응답값 == nil {
			break
		}

		값, ok := i응답값.(*xt.T0150_현물_당일_매매일지_응답)
		lb.F조건부_패닉(!ok, "TrT0150() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키_매매구분 = 값.M헤더.CTS_매매구분
		연속키_종목코드 = 값.M헤더.CTS_종목코드
		연속키_단가 = 값.M헤더.CTS_단가
		연속키_매체 = 값.M헤더.CTS_매체

		응답값_모음 = append(값.M반복값_모음, 응답값_모음...)

		if lb.F2문자열_공백_제거(연속키_매매구분) == "" &&
			lb.F2문자열_공백_제거(연속키_종목코드) == "" &&
			lb.F2문자열_공백_제거(연속키_단가) == "" &&
			lb.F2문자열_공백_제거(연속키_매체) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT0151_현물_일자별_매매일지(계좌번호 string, 일자 time.Time) (응답값_모음 []*xt.T0151_현물_일자별_매매일지_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = make([]*xt.T0151_현물_일자별_매매일지_응답_반복값, 0) }}.S실행()

	lb.F조건부_패닉(!F계좌번호_존재함(계좌번호), "존재하지 않는 계좌번호 : '%v'", 계좌번호)

	var 연속키_매매구분, 연속키_종목코드, 연속키_단가, 연속키_매체 string

	응답값_모음 = make([]*xt.T0151_현물_일자별_매매일지_응답_반복값, 0)

	for {
		질의값 := new(xt.T0151_현물_일자별_매매일지_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR현물_일자별_매매일지_t0151)
		질의값.M일자 = 일자.Format("20060102")
		질의값.M계좌번호 = 계좌번호
		질의값.M연속키_매매구분 = 연속키_매매구분
		질의값.M연속키_종목코드 = 연속키_종목코드
		질의값.M연속키_단가 = 연속키_단가
		질의값.M연속키_매체 = 연속키_매체

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		if i응답값 == nil {
			break
		}

		값, ok := i응답값.(*xt.T0151_현물_일자별_매매일지_응답)
		lb.F조건부_패닉(!ok, "TrT0151() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키_매매구분 = 값.M헤더.CTS_매매구분
		연속키_종목코드 = 값.M헤더.CTS_종목코드
		연속키_단가 = 값.M헤더.CTS_단가
		연속키_매체 = 값.M헤더.CTS_매체

		응답값_모음 = append(값.M반복값_모음, 응답값_모음...)

		if lb.F2문자열_공백_제거(연속키_매매구분) == "" &&
			lb.F2문자열_공백_제거(연속키_종목코드) == "" &&
			lb.F2문자열_공백_제거(연속키_단가) == "" &&
			lb.F2문자열_공백_제거(연속키_매체) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT0167_시각_조회() chan *xt.T0167_시각_조회_응답 {
	ch응답 := make(chan *xt.T0167_시각_조회_응답, 1)

	go func(ch응답 chan *xt.T0167_시각_조회_응답) {
		var 에러 error

		defer lb.S예외처리{M에러: &에러, M함수: func() {
			if ch응답 != nil {
				응답값 := new(xt.T0167_시각_조회_응답)
				응답값.M시각 = time.Time{}
				응답값.M에러 = 에러

				ch응답 <- 응답값
			}
		}}.S실행()

		질의값 := &lb.S질의값_기본형{M구분: xt.TR조회, M코드: xt.TR시간_조회_t0167}
		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		시각값, ok := i응답값.(time.Time)
		lb.F조건부_패닉(!ok, "TrT0167 예상하지 못한 자료형 : '%T", i응답값)

		응답값 := new(xt.T0167_시각_조회_응답)
		응답값.M시각 = 시각값
		응답값.M에러 = nil

		ch응답 <- 응답값
	}(ch응답)

	return ch응답
}

func TrT0425_현물_체결_미체결_조회(계좌번호, 종목코드 string, 체결_구분 lb.T체결_구분,
	매도_매수_구분 lb.T매도_매수_구분) (응답값_모음 []*xt.T0425_현물_체결_미체결_조회_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	lb.F확인1(F종목코드_검사(종목코드))

	응답값_모음 = make([]*xt.T0425_현물_체결_미체결_조회_응답_반복값, 0)
	연속키 := ""

	for {
		질의값 := new(xt.T0425_현물_체결_미체결_조회_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR현물_체결_미체결_조회_t0425)
		질의값.M계좌번호 = 계좌번호
		질의값.M종목코드 = 종목코드
		질의값.M체결구분 = 체결_구분
		질의값.M매도_매수_구분 = 매도_매수_구분
		질의값.M정렬구분 = lb.P정렬_정순
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		if i응답값 == nil {
			break
		}

		값, ok := i응답값.(*xt.T0425_현물_체결_미체결_조회_응답)
		lb.F조건부_패닉(!ok, "TrT0425() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키 = 값.M헤더.M연속키
		응답값_모음 = append(값.M반복값_모음, 응답값_모음...)

		if lb.F2문자열_공백_제거(연속키) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

//func TrT0434_선물옵션_체결_미체결_조회(계좌번호, 종목코드 string, 체결구분 lb.T체결_구분, 정렬구분 lb.T정렬_구분) (
//	응답값_모음 []*xt.T0434_선물옵션_체결_미체결_조회_반복값, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()
//
//	응답값_모음 = make([]*xt.T0434_선물옵션_체결_미체결_조회_반복값, 0)
//	연속키 := ""
//
//	for {
//		질의값 := new(xt.T0434_선물옵션_체결_미체결_조회_질의값)
//		질의값.S질의값_단일_종목 = lb.New질의값_단일_종목_단순형()
//		질의값.M구분 = xt.TR조회
//		질의값.M코드 = xt.TR선물옵션_체결_미체결_조회_t0434
//		질의값.M계좌번호 = 계좌번호
//		질의값.M종목코드 = 종목코드
//		질의값.M체결구분 = 체결구분
//		질의값.M정렬구분 = lb.P정렬_정순
//		질의값.M연속키 = 연속키
//
//		i응답값, 에러 := F질의_단일TR(질의값)
//		lb.F확인(에러)
//
//		if i응답값 == nil {
//			break
//		}
//
//		값, ok := i응답값.(*xt.T0434_선물옵션_체결_미체결_조회_응답)
//		lb.F조건부_패닉(!ok, "TrT0434() 예상하지 못한 자료형 : '%T'", i응답값)
//
//		연속키 = 값.M연속키
//		응답값_모음 = append(값.M반복값_모음, 응답값_모음...)
//
//		if lb.F2문자열_공백_제거(연속키) == "" {
//			break
//		}
//	}
//
//	return 응답값_모음, nil
//}

func TrT1101_현물_호가_조회(종목코드 string) (응답값 *xt.T1101_현물_호가_조회_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	질의값 := lb.New질의값_단일_종목_단순형()
	질의값.M구분 = xt.TR조회
	질의값.M코드 = xt.TR현물_호가_조회_t1101
	질의값.M종목코드 = 종목코드

	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.T1101_현물_호가_조회_응답)
	lb.F조건부_패닉(!ok, "TrT1101() 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil
}

func TrT1102_현물_시세_조회(종목코드 string) (응답값 *xt.T1102_현물_시세_조회_응답, 에러 error) {
	return TrT1102_현물_시세_조회2(종목코드, xt.P거래소_KRX)
}

func TrT1102_현물_시세_조회2(종목코드 string, 거래소_구분 xt.T거래소_구분) (응답값 *xt.T1102_현물_시세_조회_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	질의값 := xt.NewT1102_현물_시세_조회_질의값()
	질의값.M종목코드 = trade.F종목코드_보정(종목코드)
	질의값.M거래소_구분 = 거래소_구분

	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.T1102_현물_시세_조회_응답)
	lb.F조건부_패닉(!ok, "TrT1102() 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil
}

func TrT1305_기간별_주가_조회(종목코드 string, 일주월_구분 xt.T일주월년_구분, 추가_옵션_모음 ...interface{}) (
	응답값_모음 []*xt.T1305_현물_기간별_조회_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	var 수량 int
	var 일자 time.Time
	var 거래소_구분 = xt.P거래소_KRX

	for _, 추가_옵션 := range 추가_옵션_모음 {
		switch 변환값 := 추가_옵션.(type) {
		case int:
			수량 = 변환값
		case time.Time:
			일자 = 변환값
		case xt.T거래소_구분:
			거래소_구분 = 변환값
		default:
			panic(lb.New에러("예상하지 못한 옵션값 : '%T' '%v'", 추가_옵션, 추가_옵션))
		}
	}

	lb.F조건부_패닉(일주월_구분 != xt.P일주월_일 && 일주월_구분 != xt.P일주월_주 &&
		일주월_구분 != xt.P일주월_월, "예상하지 못한 일주월 구분값 : '%v'", 일주월_구분)

	거래소별_단축코드 := ""
	연속키 := ""
	응답값_모음 = make([]*xt.T1305_현물_기간별_조회_응답_반복값, 0)

	defer func() { // 순서 거꾸로 뒤집기.
		수량 = len(응답값_모음)
		응답값_모음_임시 := 응답값_모음

		응답값_모음 = make([]*xt.T1305_현물_기간별_조회_응답_반복값, 수량)

		for i, 응답값 := range 응답값_모음_임시 {
			응답값.M거래소별_단축코드 = 거래소별_단축코드
			응답값_모음[수량-i-1] = 응답값
		}
	}()

반복문:
	for {
		질의값 := xt.NewT1305_현물_기간별_조회_질의값(종목코드, 일주월_구분, 200, 거래소_구분, 연속키)

		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		값, ok := i응답값.(*xt.T1305_현물_기간별_조회_응답)
		lb.F조건부_패닉(!ok, "TrT1305() 예상하지 못한 자료형 : '%T'", i응답값)

		거래소별_단축코드 = 값.M헤더.M거래소별단축코드
		연속키 = 값.M헤더.M연속키
		응답값_모음 = append(응답값_모음, 값.M반복값_모음.M배열...)

		lb.F조건부_패닉(값.M헤더.M수량 != int64(len(값.M반복값_모음.M배열)),
			"반복값 수량 불일치. '%v', '%v'", 값.M헤더.M수량, len(값.M반복값_모음.M배열))

		if lb.F2문자열_공백_제거(연속키) == "" {
			break
		} else if 수량 > 0 && len(응답값_모음) >= 수량 { // 수량 제한 확인
			break
		} else if 일자.After(time.Time{}) { // 날짜 제한 확인
			for _, 응답값 := range 응답값_모음 {
				if 응답값.M일자.Equal(일자) || 응답값.M일자.Before(일자) {
					break 반복문
				}
			}
		}
	}

	return 응답값_모음, nil
}

func TrT1310_현물_당일전일_분틱_조회(종목코드 string, 당일_전일_구분 xt.T당일_전일_구분, 분틱_구분 xt.T분틱_구분,
	종료시각 time.Time, 추가_옵션_모음 ...interface{}) (응답값_모음 []*xt.T1310_현물_전일당일분틱조회_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	var 수량 int
	var 거래소_구분 = xt.P거래소_KRX

	for _, 추가_옵션 := range 추가_옵션_모음 {
		switch 변환값 := 추가_옵션.(type) {
		case int:
			수량 = 변환값
		case xt.T거래소_구분:
			거래소_구분 = 변환값
		default:
			panic(lb.New에러("예상하지 못한 옵션값 : '%T' '%v'", 추가_옵션, 추가_옵션))
		}
	}

	lb.F조건부_패닉(당일_전일_구분 != xt.P당일전일구분_당일 && 당일_전일_구분 != xt.P당일전일구분_전일,
		"예상하지 못한 당일_전일 구분값 : '%v'", 당일_전일_구분)

	lb.F조건부_패닉(분틱_구분 != xt.P분틱구분_분 && 분틱_구분 != xt.P분틱구분_틱,
		"예상하지 못한 분_틱 구분값 : '%v'", 분틱_구분)

	응답값_모음_역순 := make([]*xt.T1310_현물_전일당일분틱조회_응답_반복값, 0)
	연속키 := ""

	defer func() {
		일자 := lb.F조건값(당일_전일_구분 == xt.P당일전일구분_당일, F당일(), F전일())
		수량 = len(응답값_모음_역순)
		응답값_모음 = make([]*xt.T1310_현물_전일당일분틱조회_응답_반복값, len(응답값_모음_역순))

		// 종목코드, 당일/전일 설정. 시간 기준 정렬순서 변경.
		for i, 응답값 := range 응답값_모음_역순 {
			응답값.M종목코드 = 종목코드

			시각 := 응답값.M시각
			응답값.M시각 = time.Date(일자.Year(), 일자.Month(), 일자.Day(),
				시각.Hour(), 시각.Minute(), 시각.Second(), 시각.Nanosecond(), 시각.Location())

			응답값_모음[수량-1-i] = 응답값
		}
	}()

	for {
		질의값 := xt.NewT1310_현물_전일당일_분틱_조회_질의값(종목코드, 당일_전일_구분, 분틱_구분, 종료시각, 거래소_구분, 연속키)
		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		// TR전송 제한이 걸리면, 타임아웃이 되면서 데이터 수집에 오히려 방해가 됨.
		// TR전송 제한 소모 속도를 늦추어서, 타임아웃이 되지 않게 하는 것이 오히려 도움이 됨.
		lb.F대기(lb.P3초)

		값, ok := i응답값.(*xt.T1310_현물_전일당일분틱조회_응답)
		lb.F조건부_패닉(!ok, "TrT1310() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키 = 값.M헤더.M연속키
		응답값_모음_역순 = append(응답값_모음_역순, 값.M반복값_모음.M배열...)

		if lb.F2문자열_공백_제거(연속키) == "" {
			break
		} else if 수량 > 0 && len(응답값_모음_역순) >= 수량 {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT1404_관리종목_조회(시장_구분 lb.T시장구분, 관리_질의_구분 xt.T관리_질의_구분) (응답값_모음 []*xt.T1404_관리종목_조회_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	switch 시장_구분 {
	case lb.P시장구분_전체, lb.P시장구분_코스피, lb.P시장구분_코스닥:
		// OK
	default:
		return nil, lb.New에러("유효하지 않은 시장 구분값 (전체/코스피/코스닥 중 1개만 가능). %v", 시장_구분)
	}

	switch 관리_질의_구분 {
	case xt.P구분_관리, xt.P구분_불성실_공시, xt.P구분_투자_유의, xt.P구분_투자_환기:
		// OK
	default:
		return nil, lb.New에러("유효하지 않은 관리 질의 구분값 (관리/불성실 공시/투자 유지/투자 환기 중 1개만 가능). %v", 관리_질의_구분)
	}

	응답값_모음 = make([]*xt.T1404_관리종목_조회_응답_반복값, 0)
	연속키 := ""

	for {
		질의값 := new(xt.T1404_관리종목_조회_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR관리_불성실_투자유의_조회_t1404)
		질의값.M시장_구분 = 시장_구분
		질의값.M관리_질의_구분 = 관리_질의_구분
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		값, ok := i응답값.(*xt.T1404_관리종목_조회_응답)
		lb.F조건부_패닉(!ok, "TrT1404() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키 = 값.M헤더.M연속키

		응답값_모음 = append(값.M반복값_모음.M배열, 응답값_모음...)

		if lb.F2문자열_공백_제거(연속키) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT1405_투자경고_조회(시장_구분 lb.T시장구분, 투자경고_질의_구분 xt.T투자경고_질의_구분) (응답값_모음 []*xt.T1405_투자경고_조회_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	응답값_모음 = make([]*xt.T1405_투자경고_조회_응답_반복값, 0)
	연속키 := ""

	for {
		질의값 := new(xt.T1405_투자경고_조회_질의값)
		질의값.S질의값_기본형 = lb.New질의값_기본형(xt.TR조회, xt.TR투자경고_매매정지_정리매매_조회_t1405)
		질의값.M시장_구분 = 시장_구분
		질의값.M투자경고_질의_구분 = 투자경고_질의_구분
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		값, ok := i응답값.(*xt.T1405_투자경고_조회_응답)
		lb.F조건부_패닉(!ok, "TrT1405() 예상하지 못한 자료형 : '%T'", i응답값)

		응답값_모음 = append(값.M반복값_모음.M배열, 응답값_모음...)

		if 연속키 = 값.M헤더.M연속키; lb.F2문자열_공백_제거(연속키) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT1901_ETF_시세_조회(종목코드 string) (응답값 *xt.T1901_ETF_시세_조회_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	질의값 := lb.New질의값_단일_종목(xt.TR조회, xt.TR_ETF_시세_조회_t1901, 종목코드)
	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.T1901_ETF_시세_조회_응답)
	lb.F조건부_패닉(!ok, "TrT1901() 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil
}

func TrT1902_ETF_시간별_추이(종목코드 string, 추가_옵션_모음 ...interface{}) (응답값_모음 []*xt.T1902_ETF시간별_추이_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	var 수량 int
	var 시각 time.Time

	for _, 추가_옵션 := range 추가_옵션_모음 {
		switch 변환값 := 추가_옵션.(type) {
		case int:
			수량 = 변환값
		case time.Time:
			시각 = 변환값
		default:
			panic(lb.New에러("예상하지 못한 옵션값 : '%T' '%v'", 추가_옵션, 추가_옵션))
		}
	}

	응답값_모음 = make([]*xt.T1902_ETF시간별_추이_응답_반복값, 0)
	연속키 := ""

	defer func() { // 순서 거꾸로 뒤집고, 종목코드 정보 및 누락된 시각 데이터 추가.
		nil시각 := time.Time{}
		수량 := len(응답값_모음)
		응답값_모음_임시 := 응답값_모음

		응답값_모음 = make([]*xt.T1902_ETF시간별_추이_응답_반복값, 수량)

		for i, 응답값 := range 응답값_모음_임시 {
			if 응답값.M시각.Equal(nil시각) && i != 0 && !응답값_모음_임시[i-1].M시각.Equal(nil시각) {
				응답값.M시각 = 응답값_모음_임시[i-1].M시각.Add(-1 * lb.P10초)
			}

			응답값.M종목코드 = 종목코드
			응답값_모음[수량-i-1] = 응답값
		}

		for i, 응답값 := range 응답값_모음 {
			if 응답값.M시각.Equal(nil시각) && i != 0 && !응답값_모음_임시[i-1].M시각.Equal(nil시각) {
				응답값.M시각 = 응답값_모음[i-1].M시각.Add(lb.P10초)
			}
		}
	}()

	for {
		질의값 := lb.New질의값_단일종목_연속키()
		질의값.M구분 = xt.TR조회
		질의값.M코드 = xt.TR_ETF_시간별_추이_t1902
		질의값.M종목코드 = 종목코드
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		// TR전송 제한이 걸리면, 타임아웃이 되면서 데이터 수집에 오히려 방해가 됨.
		// TR전송 제한 소모 속도를 늦추어서, 타임아웃이 되지 않게 하는 것이 오히려 도움이 됨.
		lb.F대기(lb.P3초)

		값, ok := i응답값.(*xt.T1902_ETF시간별_추이_응답)
		lb.F조건부_패닉(!ok, "TrT1902() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키 = 값.M헤더.M연속키
		응답값_모음 = append(응답값_모음, 값.M반복값_모음.M배열...)

		if !시각.Equal(time.Time{}) {
			원하는_일자까지_검색 := false
			for _, 응답값 := range 응답값_모음 {
				if 응답값.M시각.Equal(시각) || 응답값.M시각.Before(시각) {
					원하는_일자까지_검색 = true
					break
				}
			}

			if 원하는_일자까지_검색 {
				break
			}
		}

		if 수량 > 0 && len(응답값_모음) >= 수량 {
			break
		} else if lb.F2문자열_공백_제거(연속키) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT1906_ETF_LP_호가_조회(종목코드 string) (응답값 *xt.T1906_ETF_LP_호가_조회_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	질의값 := lb.New질의값_단일_종목_단순형()
	질의값.M구분 = xt.TR조회
	질의값.M코드 = xt.TR_ETF_LP호가_조회_t1906
	질의값.M종목코드 = 종목코드

	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.T1906_ETF_LP_호가_조회_응답)
	lb.F조건부_패닉(!ok, "TrT1101() 예상하지 못한 자료형 : '%T'", i응답값)

	return 응답값, nil
}

// HTS 3302 화면. t3320은 참고자료로서 정보의 정확성이나 완전성은 보장하기는 어렵습니다.
func TrT3320_F기업정보_요약(종목코드 string) (응답값 *xt.T3320_기업정보_요약_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값 = nil }}.S실행()

	질의값 := lb.New질의값_단일_종목_단순형()
	질의값.M구분 = xt.TR조회
	질의값.M코드 = xt.TR기업정보_요약_t3320
	질의값.M종목코드 = 종목코드

	// TR전송 제한이 걸리면, 타임아웃이 되면서 데이터 수집에 오히려 방해가 됨.
	// TR전송 제한 소모 속도를 늦추어서, 타임아웃이 되지 않게 하는 것이 오히려 도움이 됨.
	lb.F대기(lb.P4초)

	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	응답값, ok := i응답값.(*xt.T3320_기업정보_요약_응답)
	lb.F조건부_패닉(!ok, "TrT3320() 예상하지 못한 자료형 : '%T'", i응답값)

	응답값.M종목코드 = 종목코드
	return 응답값, nil
}

// HTS 3303 화면
func TrT3341_재무_순위_종합(시장구분 lb.T시장구분, 재무순위_구분 xt.T재무순위_구분,
	추가_인수_모음 ...interface{}) (응답값_모음 []*xt.T3341_재무순위_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	switch 시장구분 {
	case lb.P시장구분_전체,
		lb.P시장구분_코스피,
		lb.P시장구분_코스닥: // OK
	default:
		panic(lb.New에러("잘못된 시장구분값 : '%s' '%d'", 시장구분, 시장구분))
	}

	switch 재무순위_구분 {
	case xt.P재무순위_매출액증가율,
		xt.P재무순위_영업이익증가율,
		xt.P재무순위_세전계속이익증가율,
		xt.P재무순위_부채비율,
		xt.P재무순위_유보율,
		xt.P재무순위_EPS,
		xt.P재무순위_BPS,
		xt.P재무순위_ROE,
		xt.P재무순위_PER,
		xt.P재무순위_PBR,
		xt.P재무순위_PEG:
		// OK
	default:
		panic(lb.New에러("잘못된 재무순위 구분값 : '%s' '%s'", string(재무순위_구분), 재무순위_구분.String()))
	}

	수량_제한 := -1
	if len(추가_인수_모음) > 0 {
		if 값, ok := 추가_인수_모음[0].(int); ok && 값 > 0 {
			수량_제한 = 값
		}
	}

	응답값_모음 = make([]*xt.T3341_재무순위_응답_반복값, 0)
	연속키 := ""

	for {
		질의값 := xt.NewT3341_재무순위_질의값()
		질의값.M시장구분 = 시장구분
		질의값.M재무순위_구분 = 재무순위_구분
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		값, ok := i응답값.(*xt.T3341_재무순위_응답)
		lb.F조건부_패닉(!ok, "TrT3341() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키 = 값.M헤더.M연속키
		응답값_모음 = append(응답값_모음, 값.M반복값_모음.M배열...)

		if 수량_제한 > 0 && len(응답값_모음) > 수량_제한 {
			return 응답값_모음, nil
		}
	}

	return 응답값_모음, nil
}

func TrT8407_현물_멀티_현재가_조회_전종목() (현재가_맵 map[string]*xt.T8407_현물_멀티_현재가_조회_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 현재가_맵 = nil }}.S실행()

	종목코드_모음_전체 := F종목코드_모음_전체()
	종목코드_모음_나머지 := 종목코드_모음_전체
	현재가_맵 = make(map[string]*xt.T8407_현물_멀티_현재가_조회_응답)

	for {
		var 종목코드_모음 []string

		if len(종목코드_모음_나머지) == 0 {
			break
		} else if len(종목코드_모음_나머지) >= 50 {
			종목코드_모음 = 종목코드_모음_나머지[:50]
			종목코드_모음_나머지 = 종목코드_모음_나머지[50:]
		} else {
			종목코드_모음 = 종목코드_모음_나머지
			종목코드_모음_나머지 = nil
		}

		응답값_맵 := lb.F확인2(TrT8407_현물_멀티_현재가_조회(종목코드_모음))

		for 키, 값 := range 응답값_맵 {
			현재가_맵[키] = 값
		}
	}

	return 현재가_맵, nil
}

func TrT8407_현물_멀티_현재가_조회(종목코드_모음_전체 []string) (응답값_맵 map[string]*xt.T8407_현물_멀티_현재가_조회_응답, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_맵 = nil }}.S실행()

	종목코드_맵 := make(map[string]lb.S비어있음)

	for _, 종목코드 := range 종목코드_모음_전체 {
		종목코드 = trade.F종목코드_보정(종목코드)

		if strings.HasPrefix(종목코드, "D") {
			continue // 채권 종목은 무시
		} else if 에러 := F종목코드_검사(종목코드); 에러 != nil {
			continue
		}

		종목코드_맵[종목코드] = lb.S비어있음{}
	}

	종목코드_모음_전체 = lb.F맵_키_모음(종목코드_맵) // 중복 및 오류 제거.

	if len(종목코드_모음_전체) == 0 {
		return make(map[string]*xt.T8407_현물_멀티_현재가_조회_응답), nil
	}

	응답값_맵 = make(map[string]*xt.T8407_현물_멀티_현재가_조회_응답)
	시작_인덱스 := 0

	for {
		if len(종목코드_모음_전체) < 시작_인덱스 {
			break
		}

		var 종목코드_모음 []string

		if len(종목코드_모음_전체) < 시작_인덱스+50 {
			종목코드_모음 = 종목코드_모음_전체[시작_인덱스:]
		} else {
			종목코드_모음 = 종목코드_모음_전체[시작_인덱스 : 시작_인덱스+50]
		}

		if len(종목코드_모음) == 0 {
			break
		}

		질의값 := lb.New질의값_복수_종목(xt.TR조회, xt.TR현물_멀티_현재가_조회_t8407, 종목코드_모음)
		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		응답값_모음, ok := i응답값.([]*xt.T8407_현물_멀티_현재가_조회_응답)
		lb.F조건부_패닉(!ok, "TrT8407() 예상하지 못한 자료형 : '%T'", i응답값)

		for _, 응답값 := range 응답값_모음 {
			응답값_맵[응답값.M종목코드] = 응답값
		}

		시작_인덱스 += 50
	}

	return 응답값_맵, nil
}

func TrT8410_현물_차트_일주월년(종목코드 string, 시작일, 종료일 time.Time, 주기구분 xt.T일주월년_구분, 수정_주가_여부 bool,
	추가_인수_모음 ...interface{}) (응답값_모음 []*xt.T8410_현물_차트_일주월년_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	종목코드 = trade.F종목코드_보정(종목코드)
	lb.F확인1(F종목코드_검사(종목코드))
	lb.F조건부_패닉(종료일.Before(시작일), "시작일자가 종료일자보다 늦습니다. %v, %v", 시작일, 종료일)

	수량_제한 := -1
	if len(추가_인수_모음) > 0 {
		if 값, ok := 추가_인수_모음[0].(int); ok && 값 > 0 {
			수량_제한 = 값
		}
	}

	응답값_모음 = make([]*xt.T8410_현물_차트_일주월년_응답_반복값, 0)
	연속일자 := ""

	defer func() {
		for _, 응답값 := range 응답값_모음 {
			응답값.M종목코드 = 종목코드
		}
	}()

	var 간격 time.Duration

	if 전송_제한_정보_모음.M맵[xt.TR현물_차트_일주월년_t8410].M10분당_전송_제한 > 0 {
		간격 = time.Duration(int64(lb.P10분) / int64(전송_제한_정보_모음.M맵[xt.TR현물_차트_일주월년_t8410].M10분당_전송_제한))
	}

	for {
		질의값 := xt.NewT8410_현물_차트_일주월년_질의값()
		질의값.M구분 = xt.TR조회
		질의값.M코드 = xt.TR현물_차트_일주월년_t8410
		질의값.M종목코드 = 종목코드
		질의값.M주기구분 = 주기구분
		질의값.M요청건수 = 2000 // 최대 압축 2000, 비압축 500
		질의값.M시작일자 = 시작일.Format("20060102")
		질의값.M종료일자 = 종료일.Format("20060102")
		질의값.M연속일자 = 연속일자
		질의값.M압축여부 = true
		질의값.M수정주가여부 = 수정_주가_여부

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		lb.F대기(간격) // TR전송 제한 고갈 예방.

		값, ok := i응답값.(*xt.T8410_현물_차트_일주월년_응답)
		lb.F조건부_패닉(!ok, "예상하지 못한 자료형 : '%T'", i응답값)

		연속일자 = 값.M헤더.M연속일자

		응답값_모음 = append(값.M반복값_모음.M배열, 응답값_모음...)

		if 수량_제한 > 0 && len(응답값_모음) > 수량_제한 {
			return 응답값_모음, nil
		}

		if lb.F2문자열_공백_제거(연속일자) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT8411_현물_차트_틱(종목코드 string, 시작일자, 종료일자 time.Time, 추가_인수_모음 ...interface{}) (응답값_모음 []*xt.T8411_현물_차트_틱_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	lb.F확인1(F종목코드_검사(종목코드))
	lb.F조건부_패닉(종료일자.Before(시작일자), "시작일자가 종료일자보다 늦습니다. %v, %v", 시작일자, 종료일자)

	수량_제한 := -1
	if len(추가_인수_모음) > 0 {
		if 값, ok := 추가_인수_모음[0].(int); ok && 값 > 0 {
			수량_제한 = 값
		}
	}

	응답값_모음 = make([]*xt.T8411_현물_차트_틱_응답_반복값, 0)
	연속일자 := ""
	연속시간 := ""

	defer func() {
		for _, 응답값 := range 응답값_모음 {
			응답값.M종목코드 = 종목코드
		}
	}()

	for {
		질의값 := xt.NewT8411_현물_차트_틱_질의값()
		질의값.M구분 = xt.TR조회
		질의값.M코드 = xt.TR현물_차트_틱_t8411
		질의값.M종목코드 = 종목코드
		질의값.M단위 = 1
		질의값.M요청건수 = 2000
		질의값.M조회영업일수 = 0
		질의값.M시작일자 = 시작일자.Format("20060102")
		질의값.M종료일자 = 종료일자.Format("20060102")
		질의값.M연속일자 = 연속일자
		질의값.M연속시간 = 연속시간
		질의값.M압축여부 = true

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		// TR전송 제한이 걸리면, 타임아웃이 되면서 데이터 수집에 오히려 방해가 됨.
		// TR전송 제한 소모 속도를 늦추어서, 타임아웃이 되지 않게 하는 것이 오히려 도움이 됨.
		lb.F대기(lb.P3초)

		값, ok := i응답값.(*xt.T8411_현물_차트_틱_응답)
		lb.F조건부_패닉(!ok, "TrT8411() 예상하지 못한 자료형 : '%T'", i응답값)

		연속일자 = 값.M헤더.M연속일자
		연속시간 = 값.M헤더.M연속시간

		응답값_모음 = append(값.M반복값_모음.M배열, 응답값_모음...)

		if 수량_제한 > 0 && len(응답값_모음) > 수량_제한 {
			return 응답값_모음, nil
		}

		if lb.F2문자열_공백_제거(연속일자) == "" || lb.F2문자열_공백_제거(연속시간) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT8412_현물_차트_분(종목코드 string, 시작일자, 종료일자 time.Time, 주기 time.Duration, 추가_인수_모음 ...interface{}) (응답값_모음 []*xt.T8412_현물_차트_분_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	lb.F확인1(F종목코드_검사(종목코드))
	lb.F조건부_패닉(종료일자.Before(시작일자), "시작일자가 종료일자보다 늦습니다. %v, %v", 시작일자, 종료일자)
	lb.F조건부_패닉(int64(주기) < 0, "0보다 짧은 마이너스 주기 : '%v'", 주기)
	lb.F조건부_패닉(int64(주기/lb.P1분) > 1440, "24시간이 넘는 주기 : '%v'", 주기)

	수량_제한 := -1
	if len(추가_인수_모음) > 0 {
		if 값, ok := 추가_인수_모음[0].(int); ok && 값 > 0 {
			수량_제한 = 값
		}
	}

	응답값_모음 = make([]*xt.T8412_현물_차트_분_응답_반복값, 0)
	연속일자 := ""
	연속시간 := ""

	defer func() {
		for _, 응답값 := range 응답값_모음 {
			응답값.M종목코드 = 종목코드
		}
	}()

	단위 := int(주기 / lb.P1분)

	for {
		질의값 := xt.NewT8412_현물_차트_분_질의값()
		질의값.M구분 = xt.TR조회
		질의값.M코드 = xt.TR현물_차트_분_t8412
		질의값.M종목코드 = 종목코드
		질의값.M단위 = 단위 // 0:30초, 1: 1분, 2: 2분, ....., n: n분
		질의값.M요청건수 = 2000
		질의값.M조회영업일수 = 0
		질의값.M시작일자 = 시작일자.Format("20060102")
		질의값.M종료일자 = 종료일자.Format("20060102")
		질의값.M연속일자 = 연속일자
		질의값.M연속시간 = 연속시간
		질의값.M압축여부 = true

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		// TR전송 제한이 걸리면, 타임아웃이 되면서 데이터 수집에 오히려 방해가 됨.
		// TR전송 제한 소모 속도를 늦추어서, 타임아웃이 되지 않게 하는 것이 오히려 도움이 됨.
		lb.F대기(lb.P3초)

		값, ok := i응답값.(*xt.T8412_현물_차트_분_응답)
		lb.F조건부_패닉(!ok, "TrT8412() 예상하지 못한 자료형 : '%T', '%v'", i응답값, len(응답값_모음))

		연속일자 = 값.M헤더.M연속일자
		연속시간 = 값.M헤더.M연속시간

		응답값_모음 = append(값.M반복값_모음.M배열, 응답값_모음...)

		if 수량_제한 > 0 && len(응답값_모음) > 수량_제한 {
			return 응답값_모음, nil
		}

		if lb.F2문자열_공백_제거(연속일자) == "" || lb.F2문자열_공백_제거(연속시간) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

func TrT8413_현물_차트_일주월(종목코드 string, 시작일, 종료일 time.Time, 주기구분 xt.T일주월년_구분,
	추가_인수_모음 ...interface{}) (응답값_모음 []*xt.T8413_현물_차트_일주월_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	종목코드 = trade.F종목코드_보정(종목코드)
	lb.F확인1(F종목코드_검사(종목코드))
	lb.F조건부_패닉(종료일.Before(시작일), "시작일자가 종료일자보다 늦습니다. %v, %v", 시작일, 종료일)

	수량_제한 := -1
	if len(추가_인수_모음) > 0 {
		if 값, ok := 추가_인수_모음[0].(int); ok && 값 > 0 {
			수량_제한 = 값
		}
	}

	응답값_모음 = make([]*xt.T8413_현물_차트_일주월_응답_반복값, 0)
	연속일자 := ""

	defer func() {
		for _, 응답값 := range 응답값_모음 {
			응답값.M종목코드 = 종목코드
		}
	}()

	var 간격 time.Duration

	if 전송_제한_정보_모음.M맵[xt.TR현물_차트_일주월_t8413].M10분당_전송_제한 > 0 {
		간격 = time.Duration(int64(lb.P10분) / int64(전송_제한_정보_모음.M맵[xt.TR현물_차트_일주월_t8413].M10분당_전송_제한))
	}

	for {
		질의값 := xt.NewT8413_현물_차트_일주월_질의값()
		질의값.M구분 = xt.TR조회
		질의값.M코드 = xt.TR현물_차트_일주월_t8413
		질의값.M종목코드 = 종목코드
		질의값.M주기구분 = 주기구분
		질의값.M요청건수 = 2000 // 최대 압축 2000, 비압축 500
		질의값.M시작일자 = 시작일.Format("20060102")
		질의값.M종료일자 = 종료일.Format("20060102")
		질의값.M연속일자 = 연속일자
		질의값.M압축여부 = true

		i응답값 := lb.F확인2(F질의_단일TR(질의값))

		lb.F대기(간격) // TR전송 제한 고갈 예방.

		값, ok := i응답값.(*xt.T8413_현물_차트_일주월_응답)
		lb.F조건부_패닉(!ok, "TrT8413() 예상하지 못한 자료형 : '%T'", i응답값)

		연속일자 = 값.M헤더.M연속일자

		응답값_모음 = append(값.M반복값_모음.M배열, 응답값_모음...)

		if 수량_제한 > 0 && len(응답값_모음) > 수량_제한 {
			return 응답값_모음, nil
		}

		if lb.F2문자열_공백_제거(연속일자) == "" {
			break
		}
	}

	return 응답값_모음, nil
}

// HTS 1503 화면
func TrT8428_증시주변자금추이(수량 int) (응답값_모음 []*xt.T8428_증시주변_자금추이_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	if 수량 <= 0 {
		return nil, lb.New에러("잘못된 수량 : '%v'", 수량)
	}

	응답값_모음 = make([]*xt.T8428_증시주변_자금추이_응답_반복값, 0)
	누적_수량 := 0
	연속키 := " "

	for {
		조회_수량 := lb.F조건값(수량 < 누적_수량+200, 수량-누적_수량, 200)
		누적_수량 += 조회_수량

		질의값 := xt.NewT8428_증시주변자금추이_질의값()
		질의값.M구분 = xt.TR조회
		질의값.M코드 = xt.TR증시_주변_자금_추이_t8428
		질의값.M수량 = 조회_수량
		질의값.M연속키 = 연속키

		i응답값 := lb.F확인2(F질의_단일TR(질의값))
		값, ok := i응답값.(*xt.T8428_증시주변_자금추이_응답)
		lb.F조건부_패닉(!ok, "TrT8428() 예상하지 못한 자료형 : '%T'", i응답값)

		연속키 = 값.M헤더.M연속키
		응답값_모음 = append(응답값_모음, 값.M반복값_모음.M배열[1:]...) // 반복 조회 1번째 값은 중복이므로 제외.

		if 누적_수량 >= 수량 {
			break
		}
	}

	역순 := 응답값_모음
	응답값_모음 = make([]*xt.T8428_증시주변_자금추이_응답_반복값, len(역순))

	for i := 0; i < len(역순); i++ {
		응답값_모음[i] = 역순[len(역순)-1-i]
	}

	return 응답값_모음, nil
}

//func TrT8432_지수선물_마스터_조회(구분 string) (응답값_모음 []*xt.T8432_지수선물_마스터_조회_반복값, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()
//
//	질의값 := lb.New질의값_문자열(xt.TR조회, xt.TR지수선물_마스터_조회_t8432, 구분)
//	i응답값, 에러 := F질의_단일TR(질의값)
//	lb.F확인(에러)
//
//	var ok bool
//	응답값_모음, ok = i응답값.([]*xt.T8432_지수선물_마스터_조회_반복값)
//	lb.F조건부_패닉(!ok, "TrT8432() 예상하지 못한 자료형 : '%T'", 응답값_모음)
//
//	return 응답값_모음, nil
//}

func TrT8436_주식종목_조회(시장_구분 lb.T시장구분) (응답값_모음 []*xt.T8436_현물_종목조회_응답_반복값, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 응답값_모음 = nil }}.S실행()

	var 시장구분_문자열 string

	switch 시장_구분 {
	case lb.P시장구분_전체:
		시장구분_문자열 = "0"
	case lb.P시장구분_코스피:
		시장구분_문자열 = "1"
	case lb.P시장구분_코스닥:
		시장구분_문자열 = "2"
	default:
		panic(lb.New에러("예상하지 못한 시장 구분값 : '%v'", 시장_구분))
	}

	질의값 := lb.New질의값_문자열(xt.TR조회, xt.TR현물_종목_조회_t8436, 시장구분_문자열)
	i응답값 := lb.F확인2(F질의_단일TR(질의값))
	값, ok := i응답값.(*xt.T8436_현물_종목조회_응답)
	lb.F조건부_패닉(!ok, "TrT8436() 예상하지 못한 자료형 : '%T'", i응답값)

	return 값.M배열, nil
}

func F질의(질의값 lb.I질의값, 옵션_모음 ...interface{}) (값 *lb.S바이트_변환_모음) {
	var 에러 error

	defer func() {
		lb.S예외처리{M에러: &에러, M함수: func() { 값 = lb.F확인2(lb.New바이트_변환_모음(lb.P변환형식_기본값, 에러)) }}.S실행()

		if 에러 != nil {
			질의_에러_연속_발생_횟수.S값(질의_에러_연속_발생_횟수.G값() + 1)
			if 질의_에러_연속_발생_횟수.G값() > 10 {
				에러 = lb.New에러with출력("xing.F질의() 10회 연속 에러 발생. 즉시 종료.")
				os.Exit(0)
			}
		} else {
			질의_에러_연속_발생_횟수.S값(0)
		}
	}()

	lb.F확인1(F질의값_종목코드_검사(질의값))

	switch 질의값.TR구분() {
	case xt.TR조회, xt.TR주문:
		f전송_권한_획득(질의값.TR코드())

		defer f전송_시각_기록(질의값.TR코드())
	default:
		// TR 전송 제한이 없는 경우에는 추가 처리 안 함. PASS
	}

	소켓REQ := 소켓REQ_저장소.G소켓()
	defer 소켓REQ_저장소.S회수(소켓REQ)

	if len(옵션_모음) > 0 {
		소켓REQ.S옵션(옵션_모음...)
	}

	return lb.F확인2(소켓REQ.G질의_응답(lb.P변환형식_기본값, 질의값))
}

func F질의_단일TR(질의값 lb.I질의값, 옵션_모음 ...interface{}) (값 interface{}, 에러 error) {
	예외_처리 := lb.S예외처리{M에러: &에러, M함수: func() { 값 = 에러 }}
	defer 예외_처리.S실행()

	타임아웃 := lb.P1분

	for _, 옵션 := range 옵션_모음 {
		switch 변환값 := 옵션.(type) {
		case time.Duration:
			타임아웃 = 변환값
		}
	}

	i식별번호 := lb.F확인2(F질의(질의값, 옵션_모음...).G해석값(0))

	switch 변환값 := i식별번호.(type) {
	case int:
		break
	case error:
		if F접속_끊김_여부() {
			return nil, nil
		}

		lb.F에러_출력(변환값)

		return nil, 변환값
	default:
		panic(lb.New에러with출력("F질의_단일TR() 예상하지 못한 자료형.\n" +
			"Xing API에서 식별번호를 부여받고, 콜백을 통해서 응답이 있는 경우에만 사용할 것.\n" +
			"그렇지 않은 경우에는 F질의()를 사용할 것.\n'%T'\n'%v'\n"))
	}

	식별번호 := i식별번호.(int)
	ch회신 := 대기소_DLL32.S추가(식별번호, 질의값.TR코드())

	select {
	case 값 := <-ch회신:
		switch 변환값 := 값.(type) {
		case error:
			if strings.Contains(변환값.Error(), "주문이 접수 대기") ||
				strings.Contains(변환값.Error(), "원주문번호를 잘못 입력") ||
				strings.Contains(변환값.Error(), "취소 가능한 수량을 초과하였습니다.") ||
				strings.Contains(변환값.Error(), "주문수량이 매매가능수량을 초과했습니다") {
				예외_처리.M출력_숨김 = true
				return nil, 변환값
			}

			fmt.Println("*********************************************************")
			fmt.Println(질의값.(fmt.Stringer).String())
			fmt.Println(변환값.Error())
			lb.F문자열_출력("*********************************************************")

			return nil, 변환값
		default:
			return 값, nil
		}
	case <-time.After(타임아웃):
		return nil, lb.New에러("타임아웃. '%v' '%v'", 질의값.TR코드(), 식별번호)
	}
}

func F접속됨() (접속됨 bool, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 접속됨 = false }}.S실행()

	질의값 := lb.New질의값_기본형(xt.TR접속됨, "")
	접속됨 = lb.F확인2(F질의(질의값, lb.P10초).G해석값(0)).(bool)

	return 접속됨, nil
}

func F계좌번호_모음() (응답값 []string, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 계좌번호_모음 = nil }}.S실행()

	if len(계좌번호_모음) != 0 {
		return 계좌번호_모음, nil
	}

	질의값 := lb.New질의값_기본형(xt.TR계좌번호_모음, "")

	계좌번호_모음 = make([]string, 0)
	if 에러 = F질의(질의값, lb.P10초).G값(0, &계좌번호_모음); 에러 != nil {
		lb.F에러_출력(에러)
		return nil, 에러
	}

	return 계좌번호_모음, nil
}

func F계좌_수량() (계좌_수량 int, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 계좌_수량 = 0 }}.S실행()

	회신_메시지 := F질의(lb.New질의값_기본형(xt.TR계좌_수량, ""))
	계좌_수량 = lb.F확인2(회신_메시지.G해석값(0)).(int)
	lb.F조건부_패닉(계좌_수량 == 0, "계좌 수량 0.")

	return 계좌_수량, nil
}

func F계좌_번호(인덱스 int) (계좌_번호 string, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 계좌_번호 = "" }}.S실행()

	회신_메시지 := F질의(lb.New질의값_정수(xt.TR계좌번호_모음, "", 인덱스))
	계좌_번호 = lb.F확인2(회신_메시지.G해석값(0)).([]string)[인덱스]

	return 계좌_번호, nil
}

func F계좌_이름(계좌_번호 string) (계좌_이름 string, 에러 error) {
	defer lb.S예외처리{M에러: &에러, M함수: func() { 계좌_이름 = "" }}.S실행()

	회신_메시지 := F질의(lb.New질의값_문자열(xt.TR계좌_이름, "", 계좌_번호))
	계좌_이름 = lb.F확인2(회신_메시지.G해석값(0)).(string)

	return 계좌_이름, nil
}

// syscall 호출 시 에러 발생. cgo방식으로만 정상 동작함. C언어 컴파일러 의존성을 없애기 위해서 비활성화.
//func F계좌_상세명(계좌_번호 string) (계좌_상세명 string, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 계좌_상세명 = "" }}.S실행()
//
//	회신_메시지 := F질의(lb.New질의값_문자열(xt.TR계좌_상세명, "", 계좌_번호))
//	계좌_상세명 = lb.F확인(회신_메시지.G해석값(0)).(string)
//
//	return 계좌_상세명, nil
//}

//func F계좌_별명(계좌_번호 string) (계좌_별명 string, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 계좌_별명 = "" }}.S실행()
//
//	회신_메시지 := F질의(lb.New질의값_문자열(xt.TR계좌_별명, "", 계좌_번호))
//	계좌_별명 = lb.F확인(회신_메시지.G해석값(0)).(string)
//
//	return 계좌_별명, nil
//}

//func F서버_이름() (서버_이름 string, 에러 error) {
//	defer lb.S예외처리{M에러: &에러, M함수: func() { 서버_이름 = "" }}.S실행()
//
//	회신_메시지 := F질의(lb.New질의값_기본형(xt.TR서버_이름, ""))
//	서버_이름 = lb.F확인(회신_메시지.G해석값(0)).(string)
//
//	return 서버_이름, nil
//}
